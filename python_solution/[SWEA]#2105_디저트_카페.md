### ğŸ“Œí’€ì´

----

#### ë‚´ê°€ ì“´ í’€ì´1(ì„±ê³µ)

- `backtracking` í™œìš©
- `check`í•¨ìˆ˜: ì‹œì‘ ìœ„ì¹˜, í˜„ì¬ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ìŒ ìœ„ì¹˜ íƒìƒ‰, ì²˜ìŒ ìœ„ì¹˜ì— ëŒì•„ì˜¤ë©´ ì¢…ë£Œ
  - ì‹œê³„ ë°©í–¥ìœ¼ë¡œ íƒìƒ‰(ì–´ë–¤ ë°©í–¥ìœ¼ë¡œ í•´ë„ ê°™ì€ ê²°ê³¼ì´ë¯€ë¡œ, í•œìª½ë§Œ ê³ ë ¤)
- ìˆœí™˜í•  ìˆ˜ ìˆëŠ” x, y ë²”ìœ„ë§Œ ì‹œì‘ì ìœ¼ë¡œ ì„¤ì •

```python
# x, y: ì²˜ìŒ ì¶œë°œì§€
# cur_x, cur_y: í˜„ì¬ ìœ„ì¹˜
# i: ëª‡ ë²ˆì§¸ íƒìƒ‰ì¸ê°€?
# flag: d ê¸°ì¤€ ì–´ëŠ ë°©í–¥ìœ¼ë¡œ ì´ë™ì¤‘ì¸ê°€?
# tmp: í˜„ì¬ íƒìƒ‰í•œ ë””ì €íŠ¸ ì¢…ë¥˜
def check(x, y, cur_x, cur_y, i, flag, tmp):
    global res
    if cur_x == x and cur_y == y and i: # ì²˜ìŒ ì¶œë°œì§€ì— ë‹¤ì‹œ ë„ì°©í•œ ê²½ìš°
        if res < i: # í¬ê¸° ë¹„êµ
            res = i
        return

    # ì´ë™ë°©í–¥ì€ í˜„ì¬ ë°©í–¥, ë˜ëŠ” ê·¸ ë‹¤ìŒ ë°©í–¥ë§Œ ê°€ëŠ¥
    # ì‹œê³„ ë°©í–¥, ë°˜ì‹œê³„ ë°©í–¥ ì „ë¶€ ê°™ì€ ê²½ìš°ì´ë¯€ë¡œ, ì‹œê³„ë°©í–¥ë§Œ íŒë‹¨
    for j in range(flag, min(4, flag + 2)):
        nx, ny = cur_x + d[j][0], cur_y + d[j][1]
        if 0 <= nx < n and 0 <= ny < n:
            if nx == x and ny == y : # ì²˜ìŒ ìœ„ì¹˜ì— ë„ì°©í•˜ëŠ” ê²½ìš°
                check(x, y, nx, ny, i + 1, j, tmp)
            elif dessert_map[ny][nx] not in tmp: # ë‹¤ìŒ ìœ„ì¹˜ì˜ ë””ì €íŠ¸ê°€ tmpì— ì—†ëŠ” ê²½ìš°, í•´ë‹¹ ìœ„ì¹˜ íƒìƒ‰
                check(x, y, nx, ny, i + 1, j, tmp + [dessert_map[ny][nx]])
            else:
                continue

                
d = [[1, 1], [-1, 1], [-1, -1], [1, -1]] # ì´ë™ ê²½ë¡œ
T = int(input())
for tc in range(1, T + 1):
    n = int(input())
    dessert_map = [list(map(int, input().split())) for _ in range(n)]
    res = -1

    for y in range(n - 2):
        for x in range(1, n - 1):
            check(x, y, x, y, 0, 0, [dessert_map[y][x]])

    print(f'#{tc} {res}')

```







#### ë‚´ê°€ ì“´ í’€ì´2(ì„±ê³µ)

```python
d = [[1, 1], [-1, 1], [-1, -1], [1, -1]]


def check(x, y, l1, l2):
    length = 2 * (l1+l2)
    tmp = [dessert_map[y][x]]
    nx, ny = x, y
    for l in range(1, length): # ê²½ë¡œë¥¼ ë°”ê¿”ê°€ë©° íƒìƒ‰
        if l <= l1:
            f = 0
        elif l <= l1+l2:
            f = 1
        elif l <= 2*l1+l2:
            f = 2
        else:
            f = 3

        nx, ny = nx+d[f][0], ny+d[f][1]
        if nx < 0 or nx >= n or ny < 0 or ny >= n: # ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°, false
            return False
        elif dessert_map[ny][nx] in tmp: # ë™ì¼í•œ ê²ƒì´ ë‚˜ì˜¤ëŠ” ê²½ìš°, false
            return False
        tmp.append(dessert_map[ny][nx])
    return True


def check_all(n): # ê° ìœ„ì¹˜ì—ì„œ ëŒ€ê°ì„  íŒë‹¨
    res = -1
    for y in range(n - 2):
        for x in range(1, n - 1):

            for l1 in range(n - x, 0, -1):  # ì˜¤ë¥¸ìª½ ì•„ë˜
                for l2 in range(x, 0, -1):  # ì™¼ìª½ ì•„ë˜
                    if check(x, y, l1, l2): # ìœ íš¨í•œ ê²½ìš°
                        res = max(res, 2 * (l1 + l2))
    return res


T = int(input())
for tc in range(1, T + 1):
    n = int(input())
    dessert_map = [list(map(int, input().split())) for _ in range(n)]
    res = check_all(n)
    print(f'#{tc} {res}')

```





### ğŸ“Œí›„ê¸°

------

