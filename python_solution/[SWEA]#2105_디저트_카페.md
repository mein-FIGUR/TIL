### 📌풀이

----

#### 내가 쓴 풀이1(성공)

- `backtracking` 활용
- `check`함수: 시작 위치, 현재 위치를 기준으로 다음 위치 탐색, 처음 위치에 돌아오면 종료
  - 시계 방향으로 탐색(어떤 방향으로 해도 같은 결과이므로, 한쪽만 고려)
- 순환할 수 있는 x, y 범위만 시작점으로 설정

```python
# x, y: 처음 출발지
# cur_x, cur_y: 현재 위치
# i: 몇 번째 탐색인가?
# flag: d 기준 어느 방향으로 이동중인가?
# tmp: 현재 탐색한 디저트 종류
def check(x, y, cur_x, cur_y, i, flag, tmp):
    global res
    if cur_x == x and cur_y == y and i: # 처음 출발지에 다시 도착한 경우
        if res < i: # 크기 비교
            res = i
        return

    # 이동방향은 현재 방향, 또는 그 다음 방향만 가능
    # 시계 방향, 반시계 방향 전부 같은 경우이므로, 시계방향만 판단
    for j in range(flag, min(4, flag + 2)):
        nx, ny = cur_x + d[j][0], cur_y + d[j][1]
        if 0 <= nx < n and 0 <= ny < n:
            if nx == x and ny == y : # 처음 위치에 도착하는 경우
                check(x, y, nx, ny, i + 1, j, tmp)
            elif dessert_map[ny][nx] not in tmp: # 다음 위치의 디저트가 tmp에 없는 경우, 해당 위치 탐색
                check(x, y, nx, ny, i + 1, j, tmp + [dessert_map[ny][nx]])
            else:
                continue

                
d = [[1, 1], [-1, 1], [-1, -1], [1, -1]] # 이동 경로
T = int(input())
for tc in range(1, T + 1):
    n = int(input())
    dessert_map = [list(map(int, input().split())) for _ in range(n)]
    res = -1

    for y in range(n - 2):
        for x in range(1, n - 1):
            check(x, y, x, y, 0, 0, [dessert_map[y][x]])

    print(f'#{tc} {res}')

```







#### 내가 쓴 풀이2(성공)

```python
d = [[1, 1], [-1, 1], [-1, -1], [1, -1]]


def check(x, y, l1, l2):
    length = 2 * (l1+l2)
    tmp = [dessert_map[y][x]]
    nx, ny = x, y
    for l in range(1, length): # 경로를 바꿔가며 탐색
        if l <= l1:
            f = 0
        elif l <= l1+l2:
            f = 1
        elif l <= 2*l1+l2:
            f = 2
        else:
            f = 3

        nx, ny = nx+d[f][0], ny+d[f][1]
        if nx < 0 or nx >= n or ny < 0 or ny >= n: # 범위를 벗어나는 경우, false
            return False
        elif dessert_map[ny][nx] in tmp: # 동일한 것이 나오는 경우, false
            return False
        tmp.append(dessert_map[ny][nx])
    return True


def check_all(n): # 각 위치에서 대각선 판단
    res = -1
    for y in range(n - 2):
        for x in range(1, n - 1):

            for l1 in range(n - x, 0, -1):  # 오른쪽 아래
                for l2 in range(x, 0, -1):  # 왼쪽 아래
                    if check(x, y, l1, l2): # 유효한 경우
                        res = max(res, 2 * (l1 + l2))
    return res


T = int(input())
for tc in range(1, T + 1):
    n = int(input())
    dessert_map = [list(map(int, input().split())) for _ in range(n)]
    res = check_all(n)
    print(f'#{tc} {res}')

```





### 📌후기

------

